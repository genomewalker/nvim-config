-- Prism.nvim socket configuration
-- Auto-generated by prism-nvim installer
-- Robust multi-instance support via socket registry

if vim.fn.has("nvim") == 1 then
  local nvim_pid = vim.fn.getpid()

  -- Use existing servername if already listening, otherwise create unique socket
  local socket_path = vim.v.servername

  if not socket_path or socket_path == "" then
    -- Generate unique socket based on PID
    socket_path = "/tmp/nvim-" .. nvim_pid .. ".sock"

    -- Start listening on unique socket
    pcall(function()
      vim.fn.serverstart(socket_path)
    end)
  end

  -- Store socket path for prism
  vim.g.prism_socket = socket_path
  vim.env.NVIM = socket_path

  -- Register socket in the registry (so MCP can find us via process tree)
  local registry_path = "/tmp/prism-socket-registry.json"

  local function register_socket()
    local registry = {}

    -- Load existing registry
    local f = io.open(registry_path, "r")
    if f then
      local content = f:read("*a")
      f:close()
      if content and content ~= "" then
        local ok, data = pcall(vim.json.decode, content)
        if ok and data then
          registry = data
        end
      end
    end

    -- Add our entry
    registry[tostring(nvim_pid)] = {
      socket = socket_path,
      registered_at = os.time(),
    }

    -- Write back
    f = io.open(registry_path, "w")
    if f then
      f:write(vim.json.encode(registry))
      f:close()
    end
  end

  local function unregister_socket()
    local registry = {}
    local f = io.open(registry_path, "r")
    if f then
      local content = f:read("*a")
      f:close()
      local ok, data = pcall(vim.json.decode, content)
      if ok and data then
        registry = data
      end
    end

    registry[tostring(nvim_pid)] = nil

    f = io.open(registry_path, "w")
    if f then
      f:write(vim.json.encode(registry))
      f:close()
    end
  end

  -- Register on startup
  register_socket()

  -- Unregister on exit
  vim.api.nvim_create_autocmd("VimLeavePre", {
    callback = unregister_socket,
  })

  -- Override termopen to pass NVIM env AND register terminal PID
  local original_termopen = vim.fn.termopen
  vim.fn.termopen = function(cmd, opts)
    opts = opts or {}
    opts.env = opts.env or {}
    opts.env.NVIM = socket_path
    opts.env.NVIM_PID = tostring(nvim_pid)

    local job_id = original_termopen(cmd, opts)

    -- Register terminal's job PID in registry too
    if job_id > 0 then
      vim.defer_fn(function()
        local term_pid = vim.fn.jobpid(job_id)
        if term_pid and term_pid > 0 then
          -- Add terminal PID to registry
          local f = io.open(registry_path, "r")
          local registry = {}
          if f then
            local content = f:read("*a")
            f:close()
            local ok, data = pcall(vim.json.decode, content)
            if ok and data then registry = data end
          end

          registry[tostring(term_pid)] = {
            socket = socket_path,
            registered_at = os.time(),
            parent_nvim = nvim_pid,
          }

          f = io.open(registry_path, "w")
          if f then
            f:write(vim.json.encode(registry))
            f:close()
          end
        end
      end, 100)
    end

    return job_id
  end
end
